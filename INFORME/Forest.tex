\chapter{Random Forests.}
El algoritmo de Random Forests consiste en un ensamble de árboles de decisión en el que cada uno contiene un bootstrap del set de datos de entrenamiento formado por atributos elegidos de forma aleatoria. El hecho de usar un subset en lugar del set de entrenamiento completo permite evitar overfitting, y el usar subconjuntos de atributos tomados al azar ayuda a determinar cuáles son los atributos que realmente resultan más importantes para la clasificación.

Random forests fue elegido ya que ofrece una gran adaptación a casi cualquier set de datos, brindando una muy buena precisión procesando grandes cantidades de datos. Además posee un muy buen tiempo de ejecución, especialmente teniendo en cuenta su efectividad. 

Este algoritmo tiene dos hiper-parámetros. Por un lado la cantidad de árboles, y por otro la cantidad de atributos de cada uno de ellos. Es fundamental para encontrar un buen funcionamiento del algoritmo hacer una buena elección de los mismos, ya que ante mayor cantidad de árboles, mejor clasificará el algoritmo, pero conllevará una pérdida de performance mayor. 

Es por eso que en las pruebas que se han realizado se intentó buscar una cantidad de árboles adecuada.
Se realizaron diferentes pruebas en Kaggle aplicando Random forests al set completo de datos modificando la cantidad de árboles predictores,  pero siempre manteniendo la misma cantidad de atributos.

Las pruebas realizadas fueron las siguientes:
\begin{enumerate}
  \item Se probó con una cantidad de 100 árboles que arrojó una efectividad de 96.514%.
  \item Se probó con una cantidad de 1000 árboles que arrojó una efectividad de 96.657%.
  \item Se probó con una cantidad de 3000 árboles que arrojó una efectividad de 96.771%.
\end{enumerate}

Se pudo observar que al superar la barrera de los 1000 árboles los cambios en los resultados que arrojaba el clasificador cada vez eran menos significativos pero aumentaban en gran manera el costo computacional, por lo que se tomó el segundo caso como el ideal para la aplicación de este algoritmo debido al equilibrio que brinda entre efectividad y performance.
